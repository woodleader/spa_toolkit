<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScreenSim Studio</title>
    <style>
        :root {
            --bg-deep: #0f172a;
            --bg-card: #1e293b;
            --card-bg: rgba(30, 41, 59, 0.7);
            --border: rgba(255, 255, 255, 0.1);
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #38bdf8;
            --accent-hover: #0ea5e9;
            --danger: #ef4444;
            --sim-bg: #000000;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-deep) 0%, #1a1a2e 100%);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(8px);
            z-index: 10;
        }

        h1 {
            font-size: 1.5rem;
            margin: 0;
            background: linear-gradient(to right, var(--accent), #818cf8);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            background: var(--accent);
            color: var(--bg-deep);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .btn-secondary:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 320px;
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 20px;
            gap: 24px;
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .select-input,
        .text-input {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            width: 100%;
            outline: none;
        }

        .select-input:focus,
        .text-input:focus {
            border-color: var(--accent);
        }

        .color-input {
            width: 100%;
            height: 40px;
            padding: 0;
            border: 1px solid var(--border);
            background: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .file-upload-label {
            display: block;
            padding: 12px;
            border: 1px dashed var(--border);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .file-upload-label:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(56, 189, 248, 0.05);
        }

        /* Stage Styles */
        .stage-area {
            flex: 1;
            background: #000;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            overflow: auto;
            position: relative;
        }

        .device-container {
            position: relative;
            background: var(--sim-bg);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            transition: width 0.3s, height 0.3s;
            flex-shrink: 0;
            overflow: hidden;
        }

        /* The inner screen content area (masked) */
        .screen-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* Prevent text bleeding */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* The Overlay SVG Frame */
        .device-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Interact 'through' the frame */
            z-index: 20;
        }

        .device-frame svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Text Elements */
        .text-layer {
            position: absolute;
            cursor: grab;
            user-select: none;
            white-space: pre;
            padding: 4px;
            border: 1px solid transparent;
            /* Selection indicator space */
            line-height: 1.2;
            z-index: 10;
        }

        .text-layer:hover {
            border-color: rgba(255, 255, 255, 0.3);
        }

        .text-layer.selected {
            border-color: var(--accent);
            background-color: rgba(56, 189, 248, 0.1);
        }

        .text-layer:active {
            cursor: grabbing;
        }

        .hidden {
            display: none !important;
        }

        /* Empty State */
        .empty-selection-msg {
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-align: center;
            margin-top: 20px;
            font-style: italic;
        }

        /* Layer List */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px;
        }

        .layer-item {
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layer-item:hover {
            background: rgba(56, 189, 248, 0.05);
            color: var(--text-primary);
        }

        .layer-item.active {
            background: rgba(56, 189, 248, 0.15);
            color: var(--accent);
            border-left: 2px solid var(--accent);
        }

        /* Visual Fidelity Layers */
        .glass-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.15) 0%,
                    rgba(255, 255, 255, 0.05) 35%,
                    rgba(255, 255, 255, 0) 50%,
                    rgba(255, 255, 255, 0.02) 100%);
            mix-blend-mode: screen;
            /* Helps it sit nicely on dark backgrounds */
            border-radius: inherit;
        }

        .bezel-shadow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 16;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.9);
            border-radius: inherit;
        }

        /* Glow Effect - Applied to container to cascade or specific elements via JS class */
        .glow-active .text-layer {
            text-shadow: 0 0 5px currentColor, 0 0 10px currentColor;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .checkbox-wrapper input {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .checkbox-wrapper:hover {
            color: var(--text-primary);
        }
    </style>
</head>

<body>
    <header>
        <div class="header-left">
            <h1>ScreenSim Studio</h1>
        </div>
        <div class="header-actions">
            <a href="../index.html" class="btn btn-secondary">Back to Toolbox</a>
            <button id="exportBtn" class="btn">
                <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                </svg>
                Download PNG
            </button>
        </div>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <!-- Global Config -->
            <div class="control-group">
                <span class="control-label">Device Preset</span>
                <select id="deviceSelect" class="select-input">
                    <option value="cluster">Auto Cluster (1920x720)</option>
                    <option value="infotainment">Infotainment (1280x800)</option>
                    <option value="tablet">Tablet (1024x1366)</option>

                    <option value="reversing">Reversing Monitor Bottom (800x480)</option>
                    <option value="reversing_side">Reversing Monitor Side (1020x560)</option>
                </select>
            </div>

            <div class="control-group">
                <span class="control-label">Visual Effects</span>
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="glowToggle">
                    <span>Enable Screen Glow</span>
                </label>
            </div>

            <div class="control-group">
                <span class="control-label">Background Image</span>
                <label class="file-upload-label">
                    <input type="file" id="bgUpload" accept="image/*" style="display: none;">
                    <span>Click to Upload BG</span>
                </label>
                <div style="display: flex; justify-content: space-between;">
                    <button id="clearBgBtn" class="btn btn-secondary" style="font-size: 0.8rem; padding: 4px 8px;">Clear
                        BG</button>
                    <div id="bgName"
                        style="font-size: 0.75rem; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 150px; align-self: center;">
                    </div>
                </div>
            </div>

            <hr style="border: 0; border-top: 1px solid var(--border); width: 100%;">

            <div class="control-group">
                <button id="addTextBtn" class="btn" style="width: 100%; justify-content: center;">
                    <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                    </svg>
                    Add Text Layer
                </button>
            </div>

            <div class="control-group">
                <span class="control-label">Layers</span>
                <div id="layerList" class="layer-list">
                    <!-- Items injected via JS -->
                    <div
                        style="padding: 10px; text-align: center; font-style: italic; font-size: 0.8rem; color: var(--text-secondary);">
                        No layers</div>
                </div>
            </div>

            <!-- Context Sensitive Properties -->
            <div id="textProperties" class="hidden">
                <div class="control-group">
                    <span class="control-label">Content</span>
                    <input type="text" id="propText" class="text-input" placeholder="Text Content">
                </div>

                <div class="control-group">
                    <span class="control-label">Font Family</span>
                    <select id="propFont" class="select-input">
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="'Courier New', monospace">Courier New</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Impact, sans-serif">Impact</option>
                        <option value="-apple-system, BlinkMacSystemFont, sans-serif">System UI</option>
                    </select>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div class="control-group">
                        <span class="control-label">Size (px)</span>
                        <input type="number" id="propSize" class="text-input" min="8" max="250" value="24">
                    </div>
                    <div class="control-group">
                        <span class="control-label">Color</span>
                        <input type="color" id="propColor" class="color-input" value="#ffffff">
                    </div>
                </div>

                <div class="control-group">
                    <button id="deleteTextBtn" class="btn"
                        style="background: var(--danger); margin-top: 10px; width: 100%; justify-content: center;">Delete
                        Element</button>
                </div>
            </div>

            <div id="noSelectionMsg" class="empty-selection-msg">
                Select a text element to edit its properties
            </div>
        </aside>

        <main class="stage-area" id="stageArea">
            <div id="deviceContainer" class="device-container"
                style="width: 1920px; height: 720px; transform: scale(0.6);">
                <div id="screenContent" class="screen-content"></div>
                <div id="deviceFrame" class="device-frame">
                    <!-- SVG Injected via JS -->
                </div>
            </div>
        </main>
    </div>

    <!-- Hidden Canvas for Export -->
    <canvas id="exportCanvas" style="display: none;"></canvas>

    <script>
        // State
        const state = {
            preset: 'cluster',
            elements: [],
            selection: null,
            bgImage: null,
            scale: 0.6,
            glowEnabled: false
        };

        // DOM Elements
        const deviceContainer = document.getElementById('deviceContainer');
        const screenContent = document.getElementById('screenContent');
        const deviceFrame = document.getElementById('deviceFrame');
        const deviceSelect = document.getElementById('deviceSelect');
        const textProperties = document.getElementById('textProperties');
        const noSelectionMsg = document.getElementById('noSelectionMsg');
        const stageArea = document.getElementById('stageArea');
        const layerList = document.getElementById('layerList');

        // Inputs
        const propText = document.getElementById('propText');
        const propFont = document.getElementById('propFont');
        const propSize = document.getElementById('propSize');
        const propColor = document.getElementById('propColor');

        // Presets Configuration
        const presets = {
            cluster: {
                width: 1920,
                height: 720,
                borderRadius: '20px',
                outerRadius: '30px',
                frame: `<svg viewBox="0 0 1920 720" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M0 0H1920V720H0V0ZM100 100C100 72.3858 122.386 50 150 50H1770C1797.61 50 1820 72.3858 1820 100V620C1820 647.614 1797.61 670 1770 670H150C122.386 670 100 647.614 100 620V100Z" fill="#111111"/>
                    <path d="M150 50H1770C1797.61 50 1820 72.3858 1820 100V620C1820 647.614 1797.61 670 1770 670H150C122.386 670 100 647.614 100 620V100C100 72.3858 122.386 50 150 50Z" stroke="#333" stroke-width="4"/>
                </svg>`
                // Simple bezel with inner cutout. The 'fill' covers the area OUTSIDE the screen. 
                // But wait, the Frame sits ON TOP. The Screen Content is BEHIND.
                // So the SVG needs a HOLE (Transparency) where the screen is.
                // Path with evenodd rule: Outer rect (Screen Size) + Inner rect (Cutout)
                // Actually easier: The SVG is just the bezel frame.
                // Let's make a frame that covers the edges.
            },
            infotainment: {
                width: 1280,
                height: 800,
                borderRadius: '20px',
                outerRadius: '30px',
                frame: `<svg viewBox="0 0 1280 800" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M0 0H1280V800H0V0ZM80 80C80 68.9543 88.9543 60 100 60H1180C1191.05 60 1200 68.9543 1200 80V720C1200 731.046 1191.05 740 1180 740H100C88.9543 740 80 731.046 80 720V80Z" fill="#222"/>
                    <circle cx="40" cy="400" r="30" fill="#444" stroke="#111" stroke-width="2"/>
                    <circle cx="1240" cy="400" r="30" fill="#444" stroke="#111" stroke-width="2"/>
                </svg>`
            },
            tablet: {
                width: 1024,
                height: 1366,
                borderRadius: '20px',
                outerRadius: '30px',
                frame: `<svg viewBox="0 0 1024 1366" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M0 0H1024V1366H0V0ZM80 40H944A20 20 0 0 1 964 60V1306A20 20 0 0 1 944 1326H80A20 20 0 0 1 60 1306V60A20 20 0 0 1 80 40Z" fill="#1a1a1a"/>
                    <circle cx="512" cy="1336" r="15" fill="#333"/>
                    <rect x="462" y="10" width="100" height="4" rx="2" fill="#333"/>
                </svg>`
            },

            reversing: {
                width: 840,
                height: 580,
                borderRadius: '20px',
                outerRadius: '30px',
                frame: `<svg viewBox="0 0 840 580" xmlns="http://www.w3.org/2000/svg">
                    <!-- Main Frame Bezel with Cutout -->
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M0 0H840V580H0V0ZM40 20H800A20 20 0 0 1 820 40V480A20 20 0 0 1 800 500H40A20 20 0 0 1 20 480V40A20 20 0 0 1 40 20Z" fill="#1a1a1a" stroke="#000" stroke-width="4"/>
                    
                    <!-- Inner Bezel Accent -->
                    <rect x="10" y="10" width="820" height="560" rx="20" fill="none" stroke="#333" stroke-width="2"/>
                    
                    <!-- Bottom Control Panel Area Background (Visual only, on top of bezel) -->
                    <!-- Actually the bezel handles the color. let's just add the controls. -->
                    
                    <!-- Controls Group shifted to bottom area (y > 500) -->
                    <g transform="translate(0, -10)">
                        <!-- Buttons container visual -->
                         <rect x="40" y="525" width="760" height="50" rx="5" fill="#2a2a2a" opacity="0.5"/>

                        <!-- Left: Down/Brightness -->
                        <rect x="150" y="535" width="70" height="30" rx="8" fill="#444" stroke="#222"/>
                        <path d="M160 550 l6 6 l6-6 Z" fill="#ccc"/>
                        <circle cx="185" cy="550" r="4" stroke="#ccc" fill="none" stroke-width="1"/>
                        <path d="M185 543 v-2 M185 557 v2 M178 550 h-2 M192 550 h2" stroke="#ccc" stroke-width="1"/> 

                        <!-- Right: Brightness/Up -->
                        <rect x="230" y="535" width="70" height="30" rx="8" fill="#444" stroke="#222"/>
                        <circle cx="255" cy="550" r="4" stroke="#ccc" fill="none" stroke-width="1"/>
                        <path d="M255 543 v-2 M255 557 v2 M248 550 h-2 M262 550 h2" stroke="#ccc" stroke-width="1"/>
                        <path d="M280 556 l6-6 l6 6 Z" fill="#ccc"/>

                        <!-- Middle: Menu, Power -->
                        <rect x="310" y="535" width="70" height="30" rx="8" fill="#444" stroke="#222"/>
                        <text x="345" y="555" text-anchor="middle" fill="#ccc" font-size="11" font-family="Arial" font-weight="bold">MENU</text>
                        
                        <rect x="390" y="530" width="80" height="40" rx="12" fill="#333" stroke="#222" stroke-width="2"/>
                        <path d="M 436 543.5 A 10 10 0 1 1 424 543.5" stroke="#ccc" fill="none" stroke-width="2" stroke-linecap="round"/>
                        <line x1="430" y1="540" x2="430" y2="550" stroke="#ccc" stroke-width="2" stroke-linecap="round"/>

                        <!-- Right: CH1, CH2, CH3 -->
                        <rect x="480" y="535" width="60" height="30" rx="8" fill="#444" stroke="#222"/>
                        <text x="510" y="555" text-anchor="middle" fill="#ccc" font-size="10" font-family="Arial" font-weight="bold">CH1</text>
                        
                        <rect x="550" y="535" width="60" height="30" rx="8" fill="#444" stroke="#222"/>
                        <text x="580" y="555" text-anchor="middle" fill="#ccc" font-size="10" font-family="Arial" font-weight="bold">CH2</text>
                        
                        <rect x="620" y="535" width="60" height="30" rx="8" fill="#444" stroke="#222"/>
                        <text x="650" y="555" text-anchor="middle" fill="#ccc" font-size="10" font-family="Arial" font-weight="bold">CH3</text>

                        <!-- Sensor / LED -->
                        <circle cx="730" cy="550" r="5" fill="#555"/>
                        <circle cx="760" cy="550" r="6" fill="#222"/>
                    </g>
                </svg>`
            },
            reversing_side: {
                width: 910,
                height: 560,
                borderRadius: '20px',
                outerRadius: '30px',
                frame: `<svg viewBox="0 0 910 560" xmlns="http://www.w3.org/2000/svg">
                    <!-- Main Frame Bezel with Cutout -->
                    <!-- Screen is 40,40 to 840,520 (800x480) -->
                    <!-- Outer frame 910x560 -->
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M0 0H910V560H0V0ZM60 40H820A20 20 0 0 1 840 60V500A20 20 0 0 1 820 520H60A20 20 0 0 1 40 500V60A20 20 0 0 1 60 40Z" fill="#1a1a1a" stroke="#000" stroke-width="4"/>
                    
                    <!-- Right Panel Decorations (Centered around x=875) -->
                    <!-- IR Receiver (Dark Square) -->
                    <!-- Center x=875. Width 24, Height 24 -> x=863 -->
                    <rect x="863" y="150" width="24" height="24" rx="4" fill="#050505" stroke="#222" stroke-width="1"/>

                    <!-- Power Button (Reduced Size) -->
                    <!-- Original R=30. New R=20. Centered at 250y -->
                    <!-- Icon also scaled down. -->
                    <circle cx="875" cy="250" r="20" fill="#333" stroke="#444" stroke-width="2"/>
                    <!-- Power Icon: cx=875, cy=250. Radius approx 8. -->
                    <!-- Arc: Start 12 o'clock gap. -->
                    <!-- M 880 244 (Right top) A 8 8 0 1 1 870 244 (Left top) -->
                    <!-- Line x1=875 y1=240 x2=875 y2=250 -->
                    <path d="M 880.5 244 A 8 8 0 1 1 869.5 244" stroke="#ccc" fill="none" stroke-width="2" stroke-linecap="round"/>
                    <line x1="875" y1="240" x2="875" y2="250" stroke="#ccc" stroke-width="2" stroke-linecap="round"/>

                    <!-- Mic Hole -->
                    <circle cx="875" cy="310" r="4" fill="#111"/>

                    <!-- Speaker Grille (Reduced width) -->
                    <g fill="#444">
                        <circle cx="865" cy="400" r="2.5"/><circle cx="875" cy="400" r="2.5"/><circle cx="885" cy="400" r="2.5"/>
                        <circle cx="865" cy="415" r="2.5"/><circle cx="875" cy="415" r="2.5"/><circle cx="885" cy="415" r="2.5"/>
                        <circle cx="865" cy="430" r="2.5"/><circle cx="875" cy="430" r="2.5"/><circle cx="885" cy="430" r="2.5"/>
                        <circle cx="865" cy="445" r="2.5"/><circle cx="875" cy="445" r="2.5"/><circle cx="885" cy="445" r="2.5"/>
                        <circle cx="865" cy="460" r="2.5"/><circle cx="875" cy="460" r="2.5"/><circle cx="885" cy="460" r="2.5"/>
                        <circle cx="865" cy="475" r="2.5"/><circle cx="875" cy="475" r="2.5"/><circle cx="885" cy="475" r="2.5"/>
                    </g>
                </svg>`
            }
        };

        // Initialization
        function init() {
            // Setup Visual Helpers
            setupVisualLayers();

            loadPreset('cluster');
            setupEventListeners();
            autoScale();
            updateLayerList();
        }

        function setupVisualLayers() {
            // Create these programmatically to ensure they exist for any logic
            const glass = document.createElement('div');
            glass.className = 'glass-overlay';
            screenContent.appendChild(glass);

            const shadow = document.createElement('div');
            shadow.className = 'bezel-shadow';
            screenContent.appendChild(shadow);
        }

        function loadPreset(key) {
            state.preset = key;
            const config = presets[key];

            // Update Device Dimensions
            deviceContainer.style.width = config.width + 'px';
            deviceContainer.style.height = config.height + 'px';

            // Apply clipping
            screenContent.style.borderRadius = config.borderRadius || '0px';
            deviceContainer.style.borderRadius = config.outerRadius || '0px';

            // Update SVG Frame
            deviceFrame.innerHTML = config.frame;

            // Auto Scale to fit view
            autoScale();
        }

        function autoScale() {
            const containerW = stageArea.clientWidth - 80; // Padding
            const containerH = stageArea.clientHeight - 80;
            const deviceW = presets[state.preset].width;
            const deviceH = presets[state.preset].height;

            const scaleX = containerW / deviceW;
            const scaleY = containerH / deviceH;
            const scale = Math.min(scaleX, scaleY, 1); // Max scale 1

            state.scale = scale;
            deviceContainer.style.transform = `scale(${scale})`;
            deviceContainer.style.transformOrigin = 'center';
        }

        // Event Listeners
        function setupEventListeners() {
            // Resize handler for auto-scale logic
            window.addEventListener('resize', autoScale);

            // Preset Select
            deviceSelect.addEventListener('change', (e) => loadPreset(e.target.value));

            // Glow Toggle
            document.getElementById('glowToggle').addEventListener('change', (e) => {
                state.glowEnabled = e.target.checked;
                if (state.glowEnabled) {
                    screenContent.classList.add('glow-active');
                } else {
                    screenContent.classList.remove('glow-active');
                }
            });

            // Background Upload
            document.getElementById('bgUpload').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        state.bgImage = evt.target.result;
                        screenContent.style.backgroundImage = `url('${state.bgImage}')`;
                        document.getElementById('bgName').textContent = file.name;
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Clear Background
            document.getElementById('clearBgBtn').addEventListener('click', () => {
                state.bgImage = null;
                screenContent.style.backgroundImage = 'none';
                document.getElementById('bgUpload').value = '';
                document.getElementById('bgName').textContent = '';
            });

            // Add Text
            document.getElementById('addTextBtn').addEventListener('click', createTextElement);

            // Delete Text
            document.getElementById('deleteTextBtn').addEventListener('click', () => {
                if (state.selection) {
                    state.selection.remove();
                    state.selection = null;
                    updateSelectionUI();
                    updateLayerList();
                }
            });

            // Properties Inputs
            [propText, propFont, propSize, propColor].forEach(el => {
                el.addEventListener('input', updateSelectedElement);
            });

            // Export
            document.getElementById('exportBtn').addEventListener('click', exportToPNG);

            // Click outside to deselect
            screenContent.addEventListener('mousedown', (e) => {
                if (e.target === screenContent) {
                    state.selection = null;
                    document.querySelectorAll('.text-layer').forEach(el => el.classList.remove('selected'));
                    updateSelectionUI();
                }
            });
        }

        function createTextElement() {
            const el = document.createElement('div');
            el.className = 'text-layer';
            el.textContent = 'New Label';
            el.style.left = '50%';
            el.style.top = '50%';
            el.style.transform = 'translate(-50%, -50%)';
            el.style.color = '#ffffff';
            el.style.fontFamily = 'Arial, sans-serif';
            el.style.fontSize = '24px';
            el.style.fontWeight = 'bold'; // Default bold for better visibility

            // Attach interaction handlers
            setupDragCapabilities(el);

            screenContent.appendChild(el);
            selectElement(el);
            updateLayerList();
        }

        function setupDragCapabilities(el) {
            let isDragging = false;
            let startX, startY;
            let startLeft, startTop;

            el.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                selectElement(el);

                isDragging = true;

                // Get start position relative to parent
                const rect = el.getBoundingClientRect();
                const parentRect = screenContent.getBoundingClientRect();

                // We need to account for scale in drag movement
                startX = e.clientX;
                startY = e.clientY;

                // Current offset
                startLeft = el.offsetLeft;
                startTop = el.offsetTop;

                // Remove center transform if present for simpler abspos, or handle it
                // We'll reset transform to none and just use Top/Left for dragging
                if (el.style.transform.includes('translate')) {
                    el.style.left = (rect.left - parentRect.left) / state.scale + 'px';
                    el.style.top = (rect.top - parentRect.top) / state.scale + 'px';
                    el.style.transform = 'none';
                    startLeft = parseFloat(el.style.left);
                    startTop = parseFloat(el.style.top);
                }

                el.style.cursor = 'grabbing';
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                // Delta divided by scale !
                const dx = (e.clientX - startX) / state.scale;
                const dy = (e.clientY - startY) / state.scale;

                el.style.left = (startLeft + dx) + 'px';
                el.style.top = (startTop + dy) + 'px';
            });

            window.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    el.style.cursor = 'grab';
                }
            });
        }

        function selectElement(el) {
            // UI Update
            document.querySelectorAll('.text-layer').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            state.selection = el;

            updateSelectionUI();
        }

        function updateSelectionUI() {
            updateLayerList(); // Refresh to show active state
            if (state.selection) {
                textProperties.classList.remove('hidden');
                noSelectionMsg.classList.add('hidden');

                // Populate fields
                propText.value = state.selection.textContent;
                propSize.value = parseInt(window.getComputedStyle(state.selection).fontSize);

                // RGB to Hex for Input Color
                const rgb = window.getComputedStyle(state.selection).color;
                propColor.value = rgbToHex(rgb);

                propFont.value = state.selection.style.fontFamily.replace(/"/g, "'");
            } else {
                textProperties.classList.add('hidden');
                noSelectionMsg.classList.remove('hidden');
            }
        }

        function updateSelectedElement() {
            if (!state.selection) return;

            state.selection.textContent = propText.value;
            state.selection.style.fontFamily = propFont.value;
            state.selection.style.fontSize = propSize.value + 'px';
            state.selection.style.color = propColor.value;
            updateLayerList(); // Update label text if changed
        }

        // Helper: RGB to Hex
        function rgbToHex(rgb) {
            if (!rgb) return '#ffffff';
            if (rgb.startsWith('#')) return rgb;
            const rgbValues = rgb.match(/\d+/g);
            if (!rgbValues) return '#ffffff';
            return "#" +
                ("0" + parseInt(rgbValues[0], 10).toString(16)).slice(-2) +
                ("0" + parseInt(rgbValues[1], 10).toString(16)).slice(-2) +
                ("0" + parseInt(rgbValues[2], 10).toString(16)).slice(-2);
        }

        function updateLayerList() {
            const layers = Array.from(document.querySelectorAll('.text-layer'));

            if (layers.length === 0) {
                layerList.innerHTML = '<div style="padding: 10px; text-align: center; font-style: italic; font-size: 0.8rem; color: var(--text-secondary);">No layers</div>';
                return;
            }

            layerList.innerHTML = '';
            layers.forEach((layer, index) => {
                const item = document.createElement('div');
                item.className = 'layer-item';
                if (state.selection === layer) item.classList.add('active');

                // Text truncated
                let text = layer.textContent || 'Layer ' + (index + 1);
                if (text.length > 20) text = text.substring(0, 20) + '...';

                item.textContent = text;
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectElement(layer);
                });

                layerList.appendChild(item);
            });
        }

        // Export Functionality
        async function exportToPNG() {
            const canvas = document.getElementById('exportCanvas');
            const ctx = canvas.getContext('2d');
            const currentPreset = presets[state.preset];

            // 1. Setup Canvas
            canvas.width = currentPreset.width;
            canvas.height = currentPreset.height;

            // 2. Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Corrected: Use clearRect instead of fillRect(transparent)
            // By default canvas is transparent. 
            // If we want a base fill (like black), we can add it, but 'transparent' is better for PNGs if desired.
            // However, screens usually are black/dark. Screen Content has background.
            // Let's fill with default black just in case bg is missing.
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 3. Draw Background Image
            if (state.bgImage) {
                // We need to load it into an Image object
                await new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        // "Cover" behavior
                        const ratio = Math.max(canvas.width / img.width, canvas.height / img.height);
                        const centerShift_x = (canvas.width - img.width * ratio) / 2;
                        const centerShift_y = (canvas.height - img.height * ratio) / 2;
                        ctx.drawImage(img, 0, 0, img.width, img.height,
                            centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
                        resolve();
                    };
                    img.src = state.bgImage;
                });
            }

            // 4. Draw Text Elements
            const elements = document.querySelectorAll('.text-layer');
            elements.forEach(el => {
                const style = window.getComputedStyle(el);

                const fontSize = style.fontSize;
                const fontFamily = style.fontFamily;
                const color = style.color;
                const text = el.textContent;

                // Coordinates relative to screenContent
                // Use offsetLeft / offsetTop directly from element which are relative to parent
                const x = el.offsetLeft;
                const y = el.offsetTop;

                // Canvas Context Font Setup
                ctx.font = `${style.fontWeight} ${fontSize} ${fontFamily}`;
                ctx.fillStyle = color;
                ctx.textBaseline = 'top';

                // Apply Shadow if Glow Enabled
                if (state.glowEnabled) {
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = color; // Glow matches text color
                } else {
                    ctx.shadowBlur = 0;
                }

                // Handle text wrapping? The tool says "Text Layers", usually single lines.
                // We'll stick to single line fillText.
                ctx.fillText(text, x, y);
            });

            // Reset Shadow for subsequent draws
            ctx.shadowBlur = 0;

            // 5. Draw Visual Effects (Glass Overlay)
            // We replicate the CSS gradient: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, ...)
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height); // 135deg approx top-left to bottom-right
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
            gradient.addColorStop(0.35, 'rgba(255, 255, 255, 0.05)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.02)');

            ctx.fillStyle = gradient;
            // Note: If we had a rounded corner clip, we should apply it here or before. 
            // But since Frame covers corners, rect is safely hidden at edges.
            ctx.globalCompositeOperation = 'screen'; // Match CSS mix-blend-mode
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over'; // Reset

            // 6. Draw SVG Frame Overlay
            // Get the current SVG string from presets (NOT from DOM, cleaner)
            const svgString = currentPreset.frame;

            // Create a Blob
            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            // Draw to Canvas
            await new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    URL.revokeObjectURL(url);
                    resolve();
                };
                img.onerror = reject;
                img.src = url;
            });

            // 7. Download
            const link = document.createElement('a');
            link.download = `screensim-${state.preset}-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Run
        init();

    </script>
</body>

</html>